(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{337:function(t,a,e){"use strict";e.r(a);var s=e(4),i=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"virtual"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#virtual"}},[t._v("#")]),t._v(" virtual")]),t._v(" "),a("h2",{attrs:{id:"explicit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#explicit"}},[t._v("#")]),t._v(" explicit")]),t._v(" "),a("h2",{attrs:{id:"inline"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#inline"}},[t._v("#")]),t._v(" inline")]),t._v(" "),a("h2",{attrs:{id:"this"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[t._v("#")]),t._v(" this")]),t._v(" "),a("h2",{attrs:{id:"template"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#template"}},[t._v("#")]),t._v(" template")]),t._v(" "),a("h2",{attrs:{id:"operator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#operator"}},[t._v("#")]),t._v(" operator")]),t._v(" "),a("p",[t._v("9、const、volatile\nconst和volatile是类型修饰符，语法类似，用于变量或函数参数声明，也可以限制非静态成员函数。const表示只读类型（指定类型安全性，保护对象不被意外修改），volatile指定被修饰的对象类型的读操作是副作用（因此读取不能被随便优化合并，适合映射I/O寄存器等）。\nvolatile:\na、当读取一个变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中，以后再取变量值时，就直接从寄存器中取值。\nb、优化器在用到volatile变量时必须每次都小心地重新读取这个变量的值，而不是使用保存到寄存器里的备份。\nc、volatile适用于多线程应用中被几个任务共享的变量。")]),t._v(" "),a("p",[t._v("15、enum\n构成枚举类型名的关键字。")]),t._v(" "),a("p",[t._v("20、inline\n内联函数，在编译时将所调用的函数代码直接嵌入到主调函数中。各个编译器的实现方式可能不同。")]),t._v(" "),a("p",[t._v("30、this\n每个类成员函数都隐含了一个this指针，用来指向类本身。this指针一般可以省略。但在赋值运算符重载的时候要显示使用。静态成员函数没有this指针。\n31、typedef\ntypedef声明，为现有数据类型创建一个新的名字。便于程序的阅读和编写。\n32、virtual\n声明虚基类，虚函数。虚函数=0时，则为纯虚函数，纯虚函数所在的类称为抽象类。")])])}),[],!1,null,null,null);a.default=i.exports}}]);