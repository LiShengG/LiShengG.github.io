(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{461:function(v,_,s){"use strict";s.r(_);var e=s(4),a=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("Redis 的事务机制是通过一组命令原子性地执行操作，确保命令在执行时不会被其他客户端打断。Redis 事务相对简单，主要依赖于三个命令："),_("code",[v._v("MULTI")]),v._v("、"),_("code",[v._v("EXEC")]),v._v(" 和 "),_("code",[v._v("WATCH")]),v._v("。")]),v._v(" "),_("h3",{attrs:{id:"redis-事务的基本概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-事务的基本概念"}},[v._v("#")]),v._v(" Redis 事务的基本概念")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("事务的定义")]),v._v(":")]),v._v(" "),_("ul",[_("li",[v._v("在 Redis 中，事务是一组命令的集合，这些命令会被按顺序执行，而不会被其他命令插入或打断。所有命令都会在一次执行中全部成功，或者在某些情况下全部不执行。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("事务的四个阶段")]),v._v(":")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("开始事务")]),v._v(": 使用 "),_("code",[v._v("MULTI")]),v._v(" 命令开始一个事务。")]),v._v(" "),_("li",[_("strong",[v._v("命令入队")]),v._v(": 事务开始后，所有的命令都会依次入队，Redis 不会立即执行这些命令。")]),v._v(" "),_("li",[_("strong",[v._v("执行事务")]),v._v(": 使用 "),_("code",[v._v("EXEC")]),v._v(" 命令提交事务，Redis 将依次执行队列中的所有命令。")]),v._v(" "),_("li",[_("strong",[v._v("放弃事务")]),v._v(": 使用 "),_("code",[v._v("DISCARD")]),v._v(" 命令可以放弃一个事务，清空命令队列。")])])])]),v._v(" "),_("h3",{attrs:{id:"事务命令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务命令"}},[v._v("#")]),v._v(" 事务命令")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("MULTI")]),v._v(":")]),v._v(" "),_("ul",[_("li",[v._v("开始一个事务。之后的命令会被放入事务队列中，等待执行。")]),v._v(" "),_("li",[v._v("执行 "),_("code",[v._v("MULTI")]),v._v(" 后，Redis 会返回 "),_("code",[v._v("OK")]),v._v(" 表示事务开始成功。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("EXEC")]),v._v(":")]),v._v(" "),_("ul",[_("li",[v._v("提交事务。Redis 会依次执行事务队列中的命令，并返回每个命令的执行结果。")]),v._v(" "),_("li",[v._v("如果事务中的任何命令执行失败，"),_("code",[v._v("EXEC")]),v._v(" 不会中止事务的执行，其他命令仍然会继续执行。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("DISCARD")]),v._v(":")]),v._v(" "),_("ul",[_("li",[v._v("放弃事务。清空事务队列，并退出事务状态。")]),v._v(" "),_("li",[v._v("执行 "),_("code",[v._v("DISCARD")]),v._v(" 后，事务中的命令将不再执行，Redis 返回 "),_("code",[v._v("OK")]),v._v(" 表示事务已取消。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("WATCH")]),v._v(":")]),v._v(" "),_("ul",[_("li",[v._v("乐观锁机制的一部分。"),_("code",[v._v("WATCH")]),v._v(" 命令用于监控一个或多个键，在 "),_("code",[v._v("EXEC")]),v._v(" 执行之前，如果被监控的键发生变化（如被其他客户端修改），整个事务会被中止，不会执行 "),_("code",[v._v("EXEC")]),v._v("。")]),v._v(" "),_("li",[v._v("这可以防止因并发修改导致的事务冲突。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("UNWATCH")]),v._v(":")]),v._v(" "),_("ul",[_("li",[v._v("取消所有通过 "),_("code",[v._v("WATCH")]),v._v(" 监控的键，通常用于放弃监控操作。")])])])]),v._v(" "),_("h3",{attrs:{id:"redis-事务的特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-事务的特点"}},[v._v("#")]),v._v(" Redis 事务的特点")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("原子性")]),v._v(":")]),v._v(" "),_("ul",[_("li",[v._v("Redis 事务内部的每条命令会按顺序依次执行，不会被其他客户端的命令插入。然而，事务并不能保证整体的原子性，也就是说，如果事务执行过程中某个命令失败，Redis 并不会自动回滚整个事务中已经执行的命令。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("隔离性")]),v._v(":")]),v._v(" "),_("ul",[_("li",[v._v("在事务执行的过程中，其他客户端无法看到事务中间状态的数据。Redis 确保事务的隔离性，通过单线程执行命令，避免了多客户端并发执行命令时的冲突。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("无回滚")]),v._v(":")]),v._v(" "),_("ul",[_("li",[v._v("Redis 的事务机制简单且高效，但没有回滚功能。一旦事务中的某个命令执行失败，其他命令仍然会继续执行，这意味着 Redis 事务在某种程度上是“部分失败”的。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("乐观锁机制（WATCH）")]),v._v(":")]),v._v(" "),_("ul",[_("li",[v._v("通过 "),_("code",[v._v("WATCH")]),v._v(" 机制，Redis 提供了一种基于乐观锁的事务控制手段。当事务提交时，如果被 "),_("code",[v._v("WATCH")]),v._v(" 的键发生了变化，"),_("code",[v._v("EXEC")]),v._v(" 会中止执行，这种方式适用于需要避免并发修改的场景。")])])])]),v._v(" "),_("h3",{attrs:{id:"事务的使用示例"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务的使用示例"}},[v._v("#")]),v._v(" 事务的使用示例")]),v._v(" "),_("h4",{attrs:{id:"简单事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简单事务"}},[v._v("#")]),v._v(" 简单事务")]),v._v(" "),_("div",{staticClass:"language-bash line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[v._v("MULTI\nSET key1 "),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"value1"')]),v._v("\nSET key2 "),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"value2"')]),v._v("\nINCR counter\nEXEC\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br")])]),_("p",[v._v("在这个例子中，"),_("code",[v._v("MULTI")]),v._v(" 开始事务，"),_("code",[v._v("SET")]),v._v(" 和 "),_("code",[v._v("INCR")]),v._v(" 命令入队，"),_("code",[v._v("EXEC")]),v._v(" 提交事务并依次执行命令。")]),v._v(" "),_("h4",{attrs:{id:"使用-watch-的事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用-watch-的事务"}},[v._v("#")]),v._v(" 使用 WATCH 的事务")]),v._v(" "),_("div",{staticClass:"language-bash line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[v._v("WATCH key1\nMULTI\nSET key1 "),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"new_value"')]),v._v("\nSET key2 "),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"value2"')]),v._v("\nEXEC\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br")])]),_("p",[v._v("这里，"),_("code",[v._v("WATCH key1")]),v._v(" 监控 "),_("code",[v._v("key1")]),v._v("。如果在 "),_("code",[v._v("EXEC")]),v._v(" 执行前，"),_("code",[v._v("key1")]),v._v(" 被其他客户端修改，事务会被中止。")]),v._v(" "),_("h3",{attrs:{id:"redis-事务的注意事项"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis-事务的注意事项"}},[v._v("#")]),v._v(" Redis 事务的注意事项")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("命令入队和执行顺序")]),v._v(":")]),v._v(" "),_("ul",[_("li",[v._v("在事务内提交的命令不会立即执行，而是会按顺序进入队列。"),_("code",[v._v("EXEC")]),v._v(" 提交后，这些命令会按顺序执行。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("事务失败的处理")]),v._v(":")]),v._v(" "),_("ul",[_("li",[v._v("事务中的某个命令执行失败，并不会导致整个事务的中止或回滚，因此在编写 Redis 事务时需要注意命令的执行顺序和依赖关系。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("WATCH 键的自动取消")]),v._v(":")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("EXEC")]),v._v(" 执行后，无论事务是否成功，"),_("code",[v._v("WATCH")]),v._v(" 的监控都会自动取消。")])])])]),v._v(" "),_("h3",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),_("p",[v._v("Redis 事务是一种轻量级的机制，能够确保一组命令按顺序执行，适用于需要多个命令组合操作的场景。然而，由于没有自动回滚的机制，对于对数据一致性要求非常高的场景，Redis 事务需要结合 "),_("code",[v._v("WATCH")]),v._v(" 和其他手段来确保数据的正确性。")])])}),[],!1,null,null,null);_.default=a.exports}}]);