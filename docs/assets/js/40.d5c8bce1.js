(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{389:function(o,t,r){"use strict";r.r(t);var _=r(4),e=Object(_.a)({},(function(){var o=this,t=o._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[t("p",[o._v("Go语言的GMP模型是Go语言实现并发编程的重要基础。GMP模型由三个核心部分组成：G（Goroutine）、M（Machine/OS线程）、P（Processor）。")]),o._v(" "),t("h3",{attrs:{id:"_1-g-goroutine"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-g-goroutine"}},[o._v("#")]),o._v(" 1. "),t("strong",[o._v("G：Goroutine")])]),o._v(" "),t("ul",[t("li",[o._v("Goroutine是Go语言中的轻量级线程。它是一个独立执行的函数，拥有自己的栈空间，可以独立运行。Goroutine非常轻量，可以在一个应用程序中创建成千上万的Goroutine，而不会占用太多资源。")])]),o._v(" "),t("h3",{attrs:{id:"_2-m-machine-os线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-m-machine-os线程"}},[o._v("#")]),o._v(" 2. "),t("strong",[o._v("M：Machine/OS线程")])]),o._v(" "),t("ul",[t("li",[o._v("M代表的是操作系统的线程。Go语言的运行时会将Goroutine分配给M去执行。一个M可以同时执行多个Goroutine，但一个M只能绑定一个P。")])]),o._v(" "),t("h3",{attrs:{id:"_3-p-processor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-p-processor"}},[o._v("#")]),o._v(" 3. "),t("strong",[o._v("P：Processor")])]),o._v(" "),t("ul",[t("li",[o._v("P表示的是逻辑处理器。它用来管理Goroutine队列，并负责调度Goroutine到M上执行。P的数量决定了程序中可以并行执行的Goroutine数量。Go语言的运行时系统会动态地调整P的数量，通过"),t("code",[o._v("runtime.GOMAXPROCS")]),o._v("函数可以控制P的数量。")])]),o._v(" "),t("h3",{attrs:{id:"_4-gmp模型的工作流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-gmp模型的工作流程"}},[o._v("#")]),o._v(" 4. "),t("strong",[o._v("GMP模型的工作流程")])]),o._v(" "),t("ul",[t("li",[o._v("当一个Go程序启动时，运行时会创建固定数量的P，每个P持有一个Goroutine队列。Goroutine在运行时创建后会被放入P的本地队列中等待调度。P会从队列中取出Goroutine，并将其分配给一个M执行。如果P的Goroutine队列为空，它会从其他P的队列或全局队列中窃取Goroutine来执行。")])]),o._v(" "),t("h3",{attrs:{id:"_5-gmp模型的优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-gmp模型的优势"}},[o._v("#")]),o._v(" 5. "),t("strong",[o._v("GMP模型的优势")])]),o._v(" "),t("ul",[t("li",[t("strong",[o._v("高效调度")]),o._v("：GMP模型允许Go语言在不需要操作系统干预的情况下进行高效的Goroutine调度，减少了线程上下文切换的开销。")]),o._v(" "),t("li",[t("strong",[o._v("轻量级并发")]),o._v("：由于Goroutine比传统的操作系统线程更加轻量，因此可以创建大量Goroutine，而不会产生高昂的资源消耗。")]),o._v(" "),t("li",[t("strong",[o._v("简单易用")]),o._v("：Go语言的并发编程模型极其简洁，开发者可以很容易地创建和管理Goroutine，而不需要过多关心底层实现细节。")])]),o._v(" "),t("h3",{attrs:{id:"_7-总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-总结"}},[o._v("#")]),o._v(" 7. "),t("strong",[o._v("总结")])]),o._v(" "),t("ul",[t("li",[o._v("GMP模型通过P（Processor）的调度将G（Goroutine）分配给M（Machine/OS线程）执行，充分利用多核CPU的资源，实现了Go语言高效的并发编程。")])]),o._v(" "),t("p",[o._v("1、什么是 GMP？（必问）")]),o._v(" "),t("p",[o._v("2、进程、线程、协程有什么区别？")]),o._v(" "),t("p",[o._v("3、抢占式调度是如何抢占的？")]),o._v(" "),t("p",[o._v("4、M 和 P 的数量问题？")])])}),[],!1,null,null,null);t.default=e.exports}}]);