---
title: 树的操作
date: 2024-08-25 08:35:26
permalink: /pages/a2da46/
author: 
  name: lisheng
  link: https://github.com/LiShengG
---




## 树Tree
二叉树
### 迭代遍历
```go
// 前序遍历
func preorderTraversal(root *TreeNode) []int {
    ans := []int{}

	if root == nil {
		return ans
	}

	st := []*TreeNode{root}

    for len(st) > 0 {
        node := st[len(st)-1]
        st = st[:len(st)-1]

        ans = append(ans, node.Val)
        if node.Right != nil {
            st = append(st, node.Right)
        }
        if node.Left != nil {
            st = append(st, node.Left)
        }
    }
    return ans
}

// 中序遍历
func inorderTraversal(root *TreeNode) []int {
    stack := []*TreeNode{}
    res := []int{}
    for root!=nil || len(stack) > 0 {
        for root != nil {
            stack = append(stack, root)
            root = root.Left
        }
        root = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        res = append(res, root.Val)
        root = root.Right
    }
    return res
}

//后续遍历
func postorderTraversal(root *TreeNode) []int {
	res := []int{}
	stk := []*TreeNode{}
	var prev *TreeNode

	for root != nil || len(stk) > 0 {
		for root != nil {
			stk = append(stk, root)
			root = root.Left
		}
        root = stk[len(stk)-1]
        stk = stk[:len(stk)-1]
        if root.Right == nil || root.Right == prev {
            res = append(res, root.Val)
            prev = root
            root = nil
        } else {
            stk = append(stk, root)
            root = root.Right
        }
	}
	return res
}

//层序遍历
func levelOrder(root *TreeNode) (res [][]int) {
    if root == nil {
        return
    }

    curLevel := []*TreeNode{root}  // 存放当前层节点
    for len(curLevel) > 0 {
        nextLevel := []*TreeNode{}  // 准备通过当前层生成下一层
        vals := []int{}

        for _, node := range curLevel {
            vals = append(vals, node.Val) // 收集当前层的值
            // 收集下一层的节点
            if node.Left != nil {
                nextLevel = append(nextLevel, node.Left)
            }
            if node.Right != nil {
                nextLevel = append(nextLevel, node.Right)
            }
        }
        res = append(res, vals)
        curLevel = nextLevel // 将下一层变成当前层
    }
    return
}
```

### 递归遍历
```go
// 前序
func preorderTraversal(root *TreeNode) []int {
    res := []int{}
    var dfs func(node *TreeNode)
    dfs = func(node *TreeNode) {
        if node == nil {
            return
        }
        res = append(res, node.Val)
        dfs(node.Left)
        dfs(node.Right)
    }
    dfs(root)
    return res
}

// 中序
func postorderTraversal(root *TreeNode) (res []int) {
    var traversal func(node *TreeNode)
    traversal = func(node *TreeNode) {
    	if node == nil {
    	    return
    	}
    	traversal(node.Left)
    	res = append(res,node.Val)
        traversal(node.Right)
    }
    traversal(root)
    return res
}

// 后续
func postorderTraversal(root *TreeNode) []int {
    res := []int{}
    var dfs func(node *TreeNode)
    dfs = func(node *TreeNode) {
        if node == nil {
            return
        }
        dfs(node.Left)
        dfs(node.Right)
        res = append(res, node.Val)
    }
    dfs(root)
    return res
}

// 层序
func levelOrder(root *TreeNode) [][]int {
	arr := [][]int{}

	depth := 0

	var order func(root *TreeNode, depth int)

	order = func(root *TreeNode, depth int) {
		if root == nil {
			return
		}
		if len(arr) == depth {
			arr = append(arr, []int{})
		}
		arr[depth] = append(arr[depth], root.Val)

		order(root.Left, depth+1)
		order(root.Right, depth+1)
	}

	order(root, depth)

	return arr
}
```
### 二叉树构造
#### [从中序、后序遍历序列构造](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
> 给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

```go
func buildTree(inorder []int, postorder []int) *TreeNode {
    if len(inorder) == 0 {
        return nil
    }

    root := &TreeNode{postorder[len(postorder)-1], nil, nil}
    i:=0
    for ; i<len(inorder); i++ {
        if root.Val == inorder[i] {
            break
        }
    }
    root.Left = buildTree(inorder[:i], postorder[:len(inorder[:i])])
    root.Right = buildTree(inorder[i+1:], postorder[len(inorder[:i]):len(postorder)-1])
    return root
}
```
#### [从前序、中序遍历序列构造](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
> 给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

```go
func buildTree(preorder []int, inorder []int) *TreeNode {
    if len(preorder) == 0 {
        return nil
    }
    root := &TreeNode{preorder[0], nil, nil}
    i:=0
    for ;i<len(inorder); i++ {
        if preorder[0] == inorder[i] {
            break
        }
    }
    root.Left = buildTree(preorder[1:len(inorder[:i])+1], inorder[:i])
    root.Right = buildTree(preorder[len(inorder[:i])+1:], inorder[i+1:])
    return root
}
```

#### [二叉搜索树的插入](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)[节点](https://leetcode.cn/problems/delete-node-in-a-bst/)
> 给你一个有根节点 `root` 的二叉树，返回它 _最深的叶节点的最近公共祖先_ 。
> 回想一下：
> - **叶节点** 是二叉树中没有子节点的节点
> - 树的根节点的 **深度 **为 `0`，如果某一节点的深度为 `d`，那它的子节点的深度就是 `d+1`
> - 如果我们假定 `A` 是一组节点 `S` 的 **最近公共祖先**，`S` 中的每个节点都在以 `A` 为根节点的子树中，且 `A` 的深度达到此条件下可能的最大值。

```go
func insertIntoBST(root *TreeNode, val int) *TreeNode {
    if root == nil {
        root = &TreeNode{Val: val}
        return root
    }
    if root.Val > val {
        root.Left = insertIntoBST(root.Left, val)
    } else {
        root.Right = insertIntoBST(root.Right, val)
    }
    return root
}

//迭代法
func insertIntoBST(root *TreeNode, val int) *TreeNode {
    if root == nil {
        return &TreeNode{Val:val}
    }
    node := root
    var pnode *TreeNode
    for node != nil {
        if val > node.Val {
            pnode = node
            node = node.Right
        } else {
            pnode = node
            node = node.Left
        }
    }
    if val > pnode.Val {
        pnode.Right = &TreeNode{Val: val}
    } else {
        pnode.Left = &TreeNode{Val: val}
    }
    return root
}
```
#### [二叉搜索树的删除节点](https://leetcode.cn/problems/delete-node-in-a-bst/)
> 给定一个二叉搜索树的根节点 **root **和一个值 **key**，删除二叉搜索树中的 **key **对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。
> 一般来说，删除节点可分为两个步骤：
> 1. 首先找到需要删除的节点；
> 2. 如果找到了，删除它。

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func deleteNode(root *TreeNode, key int) *TreeNode {
	if root == nil {
		return nil
	}
	if key < root.Val {
		root.Left = deleteNode(root.Left, key)
		return root
	}
	if key > root.Val {
		root.Right = deleteNode(root.Right, key)
		return root
	}
	if root.Right == nil {
		return root.Left
	}
	if root.Left == nil {
		return root.Right
	}
	minnode := root.Right
	for minnode.Left != nil {
		minnode = minnode.Left //找到右子树中的最小的数
	}
	root.Val = minnode.Val		//将右子树中最小的数复制给被删除节点
	root.Right = deleteNode1(root.Right) //删除右子树中最小的节点
	return root
}

func deleteNode1(root *TreeNode) *TreeNode {
	if root.Left == nil {
		pRight := root.Right //将被删除的节点的左节点本来就是nil, 右节点需要保留下来。
		root.Right = nil     //删除右子树中最小的节点
		return pRight
	}
	root.Left = deleteNode1(root.Left)
	return root
}
```
#### [修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)
> 给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 **唯一的答案** 。
> 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func trimBST(root *TreeNode, low int, high int) *TreeNode {
	if root == nil {
		return nil
	}
	if root.Val < low {
		return trimBST(root.Right, low, high)
	}
	if root.Val > high {
		return trimBST(root.Left, low, high)
	}

	root.Left = trimBST(root.Left, low, high)
	root.Right = trimBST(root.Right, low, high)

	return root
}
```
#### [将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)
> 给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 
> 平衡二叉搜索树。

```go
func sortedArrayToBST(nums []int) *TreeNode {
	if len(nums) == 0 {
		return nil
	}
	idx := len(nums) / 2
	root := &TreeNode{Val: nums[idx]}
	root.Left = sortedArrayToBST(nums[:idx])
	root.Right = sortedArrayToBST(nums[idx+1:])
	return root
}
```
### 红黑树
#### AVL & 红黑树
##### AVL树
> 平衡标准比较严格：每个左右子树的高度差不超过1
> 最大高度是 1.44 ∗ log2 n + 2 − 1.328（100W个节点，AVL树最大树高28）
> 搜索、添加、删除都是 O(logn) 复杂度，其中添加仅需 O(1) 次旋转调整、删除最多需要 O(logn) 次旋转调整


##### 红黑树
> 平衡标准比较宽松：没有一条路径会大于其他路径的2倍
> 最大高度是 2 ∗ log2(n + 1)（ 100W个节点，红黑树最大树高40）
> 搜索、添加、删除都是 O(logn) 复杂度，其中添加、删除都仅需 O(1) 次旋转调整


##### 如何选择
> 搜索的次数远远大于插入和删除，选择AVL树；搜索、插入、删除次数几乎差不多，选择红黑树
> 相对于AVL树，红黑树牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树
> 红黑树的平均统计性能优于AVL树，实际应用中更多选择使用红黑树




### 其他类型
#### [在二叉树中分配硬币](https://leetcode.cn/problems/distribute-coins-in-binary-tree/)
> 给你一个有 `n` 个结点的二叉树的根结点 `root` ，其中树中每个结点 `node` 都对应有 `node.val` 枚硬币。整棵树上一共有 `n` 枚硬币。
> 在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。移动可以是从父结点到子结点，或者从子结点移动到父结点。
> 返回使每个结点上 **只有** 一枚硬币所需的 **最少** 移动次数。

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func distributeCoins(root *TreeNode) int {
	var dfs func(node *TreeNode) (int, int)
	res := 0
	dfs = func(node *TreeNode) (int, int) {
		if node == nil {
			return 0, 0
		}
		coinL, nodeL := dfs(node.Left)
		coinR, nodeR := dfs(node.Right)
		conis := coinL + coinR + node.Val
		nodes := nodeL + nodeR + 1
		res += abs(conis, nodes)
		return conis, nodes
	}
	dfs(root)
	return res
}

func abs(x, y int) int {
	x = x - y
	if x < 0 {
		return -x
	}
	return x
}
```