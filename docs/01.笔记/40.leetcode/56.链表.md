---
title: 链表
date: 2024-08-25 08:34:44
permalink: /pages/3598d4/
author: 
  name: lisheng
  link: https://github.com/LiShengG
---
## 链表
> 定义：
> 类型：单链表、双向链表、循环链表

```go
// 有可能面试需要自定义链表
type ListNode struct {
    Val int
    Next *ListNode
}
```
### 链表高频题
#### 移除链表元素
#### 反转链表
> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

```go
哈希表哈希func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    cur := head
    for cur!=nil {
        next := cur.Next
        cur.Next = prev
        prev = cur
        cur = next
    }
    return prev
}
```
#### [K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)
> 给你链表的头节点 `head` ，每 `k`_ _个节点一组进行翻转，请你返回修改后的链表。
> `k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k`_ _的整数倍，那么请将最后剩余的节点保持原有顺序。
> 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseKGroup(head *ListNode, k int) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    tail := head
    for i := 0; i < k; i++ {
        //剩余数量小于k的话，则不需要反转。
        if (tail == nil) {
            return head;
        }
        tail = tail.Next;
    }

    // 反转前 k 个元素
    newHead := reverse(head, tail);
    //下一轮的开始的地方就是tail
    head.Next = reverseKGroup(tail, k);

    return newHead;
}

func reverse(head *ListNode, tail *ListNode) *ListNode {
    var pre *ListNode
    var next *ListNode
    for head != tail {
        next = head.Next;
        head.Next = pre;
        pre = head;
        head = next;
    }
    return pre
}
```
#### [两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)
> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

```go
func swapPairs(head *ListNode) *ListNode {
    dummy := &ListNode{
        Next: head,
    }
    //head=list[i]//pre=list[i-1]
    pre := dummy 
    for head != nil && head.Next != nil {
        pre.Next = head.Next
        next := head.Next.Next
        head.Next.Next = head
        head.Next = next
        //pre=list[(i+2)-1]
        pre = head 
        //head=list[(i+2)]
        head = next
    }
    return dummy.Next
}
```
#### 删除链表的倒数第N个节点
> 给你一个链表，删除链表的倒数第 `n`_ _个结点，并且返回链表的头结点。

```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
	dummyNode := &ListNode{0, head}
	fast, slow := dummyNode, dummyNode
	for i := 0; i <= n; i++ { // 注意<=，否则快指针为空时，慢指针正好在倒数第n个上面
		fast = fast.Next
	}
	for fast != nil {
		fast = fast.Next
		slow = slow.Next
	}
	slow.Next = slow.Next.Next
	return dummyNode.Next
}
```
#### 链表相交
> 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    l1,l2 := headA, headB
    for l1 != l2 {
        if l1 != nil {
            l1 = l1.Next
        } else {
            l1 = headB
        }

        if l2 != nil {
            l2 = l2.Next
        } else {
            l2 = headA
        }
    }

    return l1
}
```
#### [环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)
> 给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 _如果链表无环，则返回 _`_null_`

```go
func detectCycle(head *ListNode) *ListNode {
    i, cur := 0, head
    m := map[*ListNode]*ListNode{}
    for cur != nil {
        if _, ok := m[cur]; ok {
            return m[cur]
        }
        m[cur] = cur
        i++
        cur = cur.Next
    }
    return nil
}
```
### 跳表
![image.png](https://cdn.nlark.com/yuque/0/2024/png/32548312/1721381276935-499a311a-cb22-45ee-8452-9fc5fb4c151a.png#averageHue=%23faf9f7&clientId=u970f197a-38ab-4&from=paste&height=490&id=uf0b39ed6&originHeight=613&originWidth=1099&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=111710&status=done&style=none&taskId=uece81068-2e9c-48a2-a6fb-de7286c0f30&title=&width=879.2)

